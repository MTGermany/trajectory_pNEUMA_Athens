# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1get8raMa186d4Y6f6D6EyWKzZfgflrb8

# IDM calibration and simulation testing
"""

"""Importing important packages"""

import numpy as np
import pandas as pd
import math
from scipy.optimize import minimize, rosen
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button
from tqdm import tqdm
from joblib import Parallel, delayed
import multiprocessing

"""### Defining IDM class


IDM Parameters
v0:    desired speed [m/s] 
T:     desired time gap [s]
s0:    minimum gap [m]
a:     maximum acceleration [m/s^2]
b:     comfortable deceleration [m/s^2]

"""

class IDM:
    def __init__(self,v0,T,s0,a,b):
        self.v0=v0
        self.T=T
        self.s0=s0
        self.a=a
        self.b=b

        self.speed_limit = 1000
        self.bmax=9
    
    #free acceleration equation
    '''
    @param v: actual speed (m/s)
    @return : free acceleration (m/s**2)
    '''

    def calcAccFree(self,v):

        # determine valid local v0

        v0eff = np.maximum(0.01,np.minimum(self.v0,self.speed_limit))

        accFree = self.a*(1-math.pow(v/v0eff,4)) if v<v0eff else self.a*(1-(v/v0eff))

        return  accFree

    # interaction Acceleration equation

    '''
    @param s:     actual gap [m]
    @param v:     actual speed [m/s]
    @param vl:    leading speed [m/s]
    @return:  acceleration [m/s^2]
    '''

    def calcAccInt(self,s,v,vl):

        sstar = self.s0 + np.maximum(0,v*self.T + 0.5*v*(v-vl)/np.sqrt(self.a*self.b))

        accInt = -self.a*math.pow(sstar/np.maximum(s,0.1*self.s0),2)

        #return np.maximum(-self.bmax,accInt)
        return accInt

    
    # Final longitudinal acceleration equation

    def calcAccLong(self,s,v,vl):

        return np.maximum(-self.bmax,self.calcAccFree(v)+self.calcAccInt(s,v,vl))

"""### Simulation process

First observation same as from data

calculate acceleration using IDM.calcAccLong function for observed data

caluclate speed, position using ballastic approach

update gap, relative speed

calculate acceleration for updated gap, relative speed
"""

def sim(v0,T,s0,a,b, FCdata):
    
    data=FCdata
    dt=0.2
    #print(f'v0:{v0},T:{T},s0:{s0},a:{a},b:{b}')
    CF=IDM(v0,T,s0,a,b)    # IDM model as defined above
    
    #First step as per oberved data
    data.loc[0,'v1']=data.loc[0,'vx[m/s]'] 
    data.loc[0,'x1']=data.loc[0,'x[m]']
    data.loc[0,'gap1']=data.loc[0,'gap[m]']
    #data.loc['accln']=data.apply(lambda x: CF.calcAccLong(x['gap1'],x['v1'],x['lead_vx']),axis=1) 
    data.loc[0,'accln']=CF.calcAccLong(data.loc[0,'gap1'],data.loc[0,'v1'],data.loc[0,'lead_vx']) 
    
    
    for i in range(1,len(data)):

        if data.loc[i,'leadID']!=data.loc[i-1,'leadID']:  # to check if leader is same or not
            
            #if leader is not same then update speed and position to observed 
            data.loc[i,'v1']=data.loc[i,'vx[m/s]']
            data.loc[i,'x1']=data.loc[i,'x[m]']
   
        else:
            data.loc[i,'v1']=data.loc[i-1,'v1']+data.loc[i-1,'accln']*dt  #calculation of simulated speed "hatv" using previous step v and acc
            data.loc[i,'x1']=data.loc[i-1,'x1']+ data.loc[i-1,'v1']*dt+0.5*data.loc[i-1,'accln']*dt*dt #calculation of simulated position "hatx" using previous step x, v and acc

            #New approach by IDM calibtraj

            #data.loc[i,'gap1']=data.loc[i-1,'gap1']+0.5*dt*(data.loc[i-1,'lead_vx']+data.loc[i,'lead_vx']) - 0.5*dt*(data.loc[i-1,'v1']+data.loc[i,'v1'])
            
            if data.loc[i,'v1']<-1e-6:
                data.loc[i,'v1']=0
                data.loc[i,'x1']=data.loc[i-1,'x1']-0.5*data.loc[i-1,'v1']**2/data.loc[i-1,'accln']
                #data.loc[i,'gap1']=data.loc[i,'gap[m]']+data.loc[i,'x[m]']-data.loc[i,'x1'] #calculation of simulated gap hats using current step simulated x and leader position
        data.loc[i,'gap1']=data.loc[i,'gap[m]']+data.loc[i,'x[m]']-data.loc[i,'x1']
        data.loc[i,'accln']=CF.calcAccLong(data.loc[i,'gap1'],data.loc[i,'v1'],data.loc[i,'lead_vx']) #calcualation of acceleration hata using current step "hatv","hats", leadv
    
    sse= sum((data['gap1']-data['gap[m]'])**2)
    
    avg_error=sum(abs(data['gap1']-data['gap[m]']))/len(data)
    return  [sse,avg_error,data]

#function to load trajectory data in csv format from FCdata files
"""
@param i: subject ID

return data
"""
def singleleader(i,j):
    #path=fr"D:\TU Dresden\RA\pneuma dataset\export2022_11_25_simpleCases\export2022_11_25_simpleCases\d8_0900_0930_road{i}_veh{j}.FCdata"
    path=fr"d8_0900_0930_road{i}_veh{j}.FCdata"
    
    _data=[]
    with open(path,'r') as f:

        for index,line in enumerate(f):

            if index ==8:
                as_list=line.split()
                as_list[0]='time[s]'
                header=as_list
            if index>8:
                _data.append(line.split())

    FCdata=pd.DataFrame(_data,columns=header)
    FCdata=FCdata.apply(pd.to_numeric,errors='coerce') # to convert data from object to numeric with NA
    return FCdata

"""### Subject Vehicle 145"""

print('FOLLOWING RESULTS ARE FOR SUBJECT 145')
#load data
FCdata145=singleleader(2,145)

"""Calibrated parameters and result as per file "d8_0900_0930_road2_veh145_IDM_s.out"

v0=13.785, T=1.522, s0=0.590, a=1.670, b=5.252

resuting_SSE for above parameters: 458.24
average error=0.66m

### Reproduction of result by calibrated parameters to check if IDM is defined correctly and simulation process is done correctly
"""

sim145=sim(v0=13.785,T=1.522,s0=0.59,a=1.670,b=5.252,FCdata=FCdata145)

sse=sim145[0]
avg_error=sim145[1]

print(f'Subject 145: For simulation by Ankit: sse is {sse} and average error is {avg_error}m')
print(f'Subject 145: For simulation by Martin: sse is 458.24 and average error is 0.66 m')

def speed_gap_plt(data):
    fig, axes=plt.subplots(2,1)
    ax=axes[0]
    ax.plot(data['time[s]'],data['vx[m/s]'],label='Data')
    ax.plot(data['time[s]'],data['v1'],label='IDM')
    ax.plot(data['time[s]'],data['lead_vx'],label='Leader')
    ax.set_ylabel('Speed')
    ax.legend()
    ax=axes[1]
    ax.plot(data['time[s]'],data['gap[m]'],label='Data')
    ax.plot(data['time[s]'],data['gap1'],label='IDM')
    ax.legend()
    ax.set_ylabel('Gap')
    ax.set_xlabel('Time')
    
    plt.show()

speed_gap_plt(sim145[2])

"""Simualtion results Comparison for b0 and b1

From given results

for base values: sse= 458.238

case 1: beta0 = 3.883500; beta1=1.280662; sse=4582.383299

case 2: beta0 = 9.095485; beta1=1.586720; sse=717.194578

case 3: beta0 = 22.125448; beta1=1.618937; sse=496.833316
"""

sim_b0_b1_1=sim(v0=3.883500,T=1.280662,s0=0.59,a=1.670,b=5.252,FCdata=FCdata145)

print(f'Subject 145: : 1. sse is {sim_b0_b1_1[0]}')

sim_b0_b1_2=sim(v0=9.095485,T=1.586720,s0=0.59,a=1.670,b=5.252,FCdata=FCdata145)

print(f'Subject 145: 2. sse is {sim_b0_b1_2[0]}')

sim_b0_b1_3=sim(v0=22.125448,T=1.618937,s0=0.59,a=1.670,b=5.252,FCdata=FCdata145)

print(f'Subject 145: 3. sse is {sim_b0_b1_3[0]}')

"""Comparison for b2 and b4

From given results

for base values: sse= 458.238

case 1: beta2 = 0.254847; beta4=0.050000; sse=4582.383299

case 2: beta2 = 0.366526; beta4=8.673333; sse=1112.240258

case 3: beta2 = 0.411198; beta4=5.025000; sse=496.803967
"""

sim_b2_b4_1=sim(v0=13.7852,T=1.52229,s0=0.254847,a=1.670,b=0.050000,FCdata=FCdata145)

print(f'Subject 145: 1. sse is {sim_b2_b4_1[0]}')

sim_b2_b4_2=sim(v0=13.7852,T=1.52229,s0=0.366526,a=1.670,b=8.673333,FCdata=FCdata145)

print(f'Subject 145: 2. sse is {sim_b2_b4_2[0]}')

sim_b2_b4_3=sim(v0=13.7852,T=1.52229,s0=0.411198,a=1.670,b=5.025000,FCdata=FCdata145)

print(f'Subject 145: 3. sse is {sim_b2_b4_3[0]}')

"""### From above results of calculation of b0-b1 and b2-b4 sse results are not same as per given files

So we need to check exactly where the error is
"""

# For subject vehicle 145

b0=np.linspace(3.8835,42.973388,31)
b1=np.linspace(1.280662,1.763912,31)
b2=np.linspace(0.254847,0.924925,31)
b3=np.linspace(1.093148,2.246929,31)
b4=np.linspace(0.05,10,31)

b0b1=(np.array(np.meshgrid(b0,b1)).T.reshape(-1,2))
b0b2=(np.array(np.meshgrid(b0,b2)).T.reshape(-1,2))
b0b3=(np.array(np.meshgrid(b0,b3)).T.reshape(-1,2))
b0b4=(np.array(np.meshgrid(b0,b4)).T.reshape(-1,2))
b1b2=(np.array(np.meshgrid(b1,b2)).T.reshape(-1,2))
b1b3=(np.array(np.meshgrid(b1,b3)).T.reshape(-1,2))
b1b4=(np.array(np.meshgrid(b1,b4)).T.reshape(-1,2))
b2b3=(np.array(np.meshgrid(b2,b3)).T.reshape(-1,2))
b2b4=(np.array(np.meshgrid(b2,b4)).T.reshape(-1,2))
b3b4=(np.array(np.meshgrid(b3,b4)).T.reshape(-1,2))

def sim_sse_145(v0=13.785,T=1.522,s0=0.59,a=1.670,b=5.252,FCdata=FCdata145):
    
    data=FCdata
    dt=0.2
    #print(f'v0:{v0},T:{T},s0:{s0},a:{a},b:{b}')
    CF=IDM(v0,T,s0,a,b)    # IDM model as defined above
    
    #First step as per oberved data
    data.loc[0,'v1']=data.loc[0,'vx[m/s]'] 
    data.loc[0,'x1']=data.loc[0,'x[m]']
    data.loc[0,'gap1']=data.loc[0,'gap[m]']
    #data.loc['accln']=data.apply(lambda x: CF.calcAccLong(x['gap1'],x['v1'],x['lead_vx']),axis=1) 
    data.loc[0,'accln']=CF.calcAccLong(data.loc[0,'gap1'],data.loc[0,'v1'],data.loc[0,'lead_vx']) 
    for i in range(1,len(data)):

        if data.loc[i,'leadID']!=data.loc[i-1,'leadID']:  # to check if leader is same or not
            
            #if leader is not same then update speed and position to observed 
            data.loc[i,'v1']=data.loc[i,'vx[m/s]']
            data.loc[i,'x1']=data.loc[i,'x[m]']
   
        else:
            data.loc[i,'v1']=data.loc[i-1,'v1']+data.loc[i-1,'accln']*dt  #calculation of simulated speed "hatv" using previous step v and acc
            data.loc[i,'x1']=data.loc[i-1,'x1']+ data.loc[i-1,'v1']*dt+0.5*data.loc[i-1,'accln']*dt*dt #calculation of simulated position "hatx" using previous step x, v and acc
            if data.loc[i,'v1']<-1e-6:
                data.loc[i,'v1']=0
                data.loc[i,'x1']=data.loc[i-1,'x1']-0.5*data.loc[i-1,'v1']**2/data.loc[i-1,'accln']
        data.loc[i,'gap1']=data.loc[i,'gap[m]']+data.loc[i,'x[m]']-data.loc[i,'x1'] #calculation of simulated gap hats using current step simulated x and leader position
        data.loc[i,'accln']=CF.calcAccLong(data.loc[i,'gap1'],data.loc[i,'v1'],data.loc[i,'lead_vx']) #calcualation of acceleration hata using current step "hatv","hats", leadv
    
    sse= sum((data['gap1']-data['gap[m]'])**2)
    avg_error=sum(abs(data['gap1']-data['gap[m]']))/len(data)
    return  sse

num_cores = multiprocessing.cpu_count()
resultsb01 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(v0=i[0],T=i[1]) for i in b0b1)
resultsb02 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(v0=i[0],s0=i[1]) for i in b0b2)
resultsb03 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(v0=i[0],a=i[1]) for i in b0b3)
resultsb04 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(v0=i[0],b=i[1]) for i in b0b4)
resultsb12 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(T=i[0],s0=i[1]) for i in b1b2)
resultsb13 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(T=i[0],a=i[1]) for i in b1b3)
resultsb14 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(T=i[0],b=i[1]) for i in b1b4)
resultsb23 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(s0=i[0],a=i[1]) for i in b2b3)
resultsb24 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(s0=i[0],b=i[1]) for i in b2b4)
resultsb34 = Parallel(n_jobs=num_cores)(delayed(sim_sse_145)(a=i[0],b=i[1]) for i in b3b4)

result_145=[resultsb01,resultsb02,resultsb03,resultsb04,resultsb12,resultsb13,resultsb14,resultsb23,resultsb24,resultsb34]

res_145=[np.array(result_145[i]).reshape(31,31) for i in range(10)]

def plot_v0(res=res_145):
    fig,axes=plt.subplots(4,1,figsize=(8,15))
    ax=axes[0]
    im=ax.contourf(b0, b4, np.transpose(res[3]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('b')
    ax=axes[1]
    im=ax.contourf(b0, b3, np.transpose(res[2]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('a')
    ax=axes[2]
    im=ax.contourf(b0, b2, np.transpose(res[1]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('s0')
    ax=axes[3]
    im=ax.contourf(b0, b1, np.transpose(res[0]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('T')
    ax.set_xlabel('v0')
    #plt.colorbar(ax=ax)

    plt.show()

def plot_T(res=res_145):
    fig,axes=plt.subplots(3,1)
    ax=axes[0]
    im=ax.contourf(b1, b4, np.transpose(res[6]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('b')
    ax=axes[1]
    im=ax.contourf(b1, b3, np.transpose(res[5]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('a')
    ax=axes[2]
    im=ax.contourf(b1, b2, np.transpose(res[4]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('s0')
    ax.set_xlabel('T')

    plt.show()


def plot_s0(res=res_145):
    fig,axes=plt.subplots(2,1)
    ax=axes[0]
    im=ax.contourf(b2, b4, np.transpose(res[8]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('b')
    ax=axes[1]
    im=ax.contourf(b2, b4, np.transpose(res[7]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('a')
    ax.set_xlabel('s0')

    plt.show()



def plot_a(res=res_145):
    fig,ax=plt.subplots()
    
    im=ax.contourf(b3, b4, np.transpose(res[9]), cmap='Dark2')
    plt.colorbar(im,ax=ax)
    ax.set_ylabel('b')
    ax.set_xlabel('a')
 

    plt.show()

plot_v0(res=res_145)
plot_T(res=res_145)
plot_s0(res=res_145)
plot_a(res=res_145)

"""### Subject Vehicle 157"""

print('FOLLOWING RESULTS ARE FOR SUBJECT 157')
FCdata157=singleleader(2,157)

"""Calibrated parameters and result as per file "d8_0900_0930_road2_veh157_IDM_s.out"

v0=6.882, T=1.404, s0=0.421, a=0.969, b=4.701

resuting_SSE for above parameters: 833.95
average error=0.82m

"""

sim157=sim(v0=6.882, T=1.404, s0=0.421, a=0.969, b=4.701,FCdata=FCdata157)

sse=sim157[0]
avg_error=sim157[1]

print(f'Subject: 157,   For simulation by Ankit, sse is {sse} and average error is {avg_error}m')
print(f'Subject: 157,  For simulaiton by Martin, sse is 833.95 and average error is 0.82 m')

"""Results of SSE in given output is not same as per computed"""

speed_gap_plt(sim157[2])

# parameters for 157
b0=np.linspace(5.840373,7.923885,31)
b1=np.linspace(1.046255,1.762533,31)
b2=np.linspace(0.061889,0.780520,31)
b3=np.linspace(0.747628,1.189744,31)
b4=np.linspace(0.05,10,31)

b0b1=(np.array(np.meshgrid(b0,b1)).T.reshape(-1,2))
b0b2=(np.array(np.meshgrid(b0,b2)).T.reshape(-1,2))
b0b3=(np.array(np.meshgrid(b0,b3)).T.reshape(-1,2))
b0b4=(np.array(np.meshgrid(b0,b4)).T.reshape(-1,2))
b1b2=(np.array(np.meshgrid(b1,b2)).T.reshape(-1,2))
b1b3=(np.array(np.meshgrid(b1,b3)).T.reshape(-1,2))
b1b4=(np.array(np.meshgrid(b1,b4)).T.reshape(-1,2))
b2b3=(np.array(np.meshgrid(b2,b3)).T.reshape(-1,2))
b2b4=(np.array(np.meshgrid(b2,b4)).T.reshape(-1,2))
b3b4=(np.array(np.meshgrid(b3,b4)).T.reshape(-1,2))

def sim_sse_157(v0=6.882, T=1.404, s0=0.421, a=0.969, b=4.701,FCdata=FCdata157):
    
    data=FCdata
    dt=0.2
   # print(f'v0:{v0},T:{T},s0:{s0},a:{a},b:{b}')
    CF=IDM(v0,T,s0,a,b)    # IDM model as defined above
    
    #First step as per oberved data
    data.loc[0,'v1']=data.loc[0,'vx[m/s]'] 
    data.loc[0,'x1']=data.loc[0,'x[m]']
    data.loc[0,'gap1']=data.loc[0,'gap[m]']
    #data.loc['accln']=data.apply(lambda x: CF.calcAccLong(x['gap1'],x['v1'],x['lead_vx']),axis=1) 
    data.loc[0,'accln']=CF.calcAccLong(data.loc[0,'gap1'],data.loc[0,'v1'],data.loc[0,'lead_vx']) 
    for i in range(1,len(data)):

        if data.loc[i,'leadID']!=data.loc[i-1,'leadID']:  # to check if leader is same or not
            
            #if leader is not same then update speed and position to observed 
            data.loc[i,'v1']=data.loc[i,'vx[m/s]']
            data.loc[i,'x1']=data.loc[i,'x[m]']
   
        else:
            data.loc[i,'v1']=data.loc[i-1,'v1']+data.loc[i-1,'accln']*dt  #calculation of simulated speed "hatv" using previous step v and acc
            data.loc[i,'x1']=data.loc[i-1,'x1']+ data.loc[i-1,'v1']*dt+0.5*data.loc[i-1,'accln']*dt*dt #calculation of simulated position "hatx" using previous step x, v and acc
            if data.loc[i,'v1']<-1e-6:
                data.loc[i,'v1']=0
                data.loc[i,'x1']=data.loc[i-1,'x1']-0.5*data.loc[i-1,'v1']**2/data.loc[i-1,'accln']
        data.loc[i,'gap1']=data.loc[i,'gap[m]']+data.loc[i,'x[m]']-data.loc[i,'x1'] #calculation of simulated gap hats using current step simulated x and leader position
        data.loc[i,'accln']=CF.calcAccLong(data.loc[i,'gap1'],data.loc[i,'v1'],data.loc[i,'lead_vx']) #calcualation of acceleration hata using current step "hatv","hats", leadv
    
    sse= sum((data['gap1']-data['gap[m]'])**2)
    avg_error=sum(abs(data['gap1']-data['gap[m]']))/len(data)
    return  sse

resultsb01= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(v0=i[0],T=i[1]) for i in b0b1)
resultsb02= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(v0=i[0],s0=i[1]) for i in b0b2)
resultsb03= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(v0=i[0],a=i[1]) for i in b0b3)
resultsb04= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(v0=i[0],b=i[1]) for i in b0b4)
resultsb12= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(T=i[0],s0=i[1]) for i in b1b2)
resultsb13= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(T=i[0],a=i[1]) for i in b1b3)
resultsb14= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(T=i[0],b=i[1]) for i in b1b4)
resultsb23= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(s0=i[0],a=i[1]) for i in b2b3)
resultsb24= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(s0=i[0],b=i[1]) for i in b2b4)
resultsb34= Parallel(n_jobs=num_cores)(delayed(sim_sse_157)(a=i[0],b=i[1]) for i in b3b4)

result_157=[resultsb01,resultsb02,resultsb03,resultsb04,resultsb12,resultsb13,resultsb14,resultsb23,resultsb24,resultsb34]

res_157=[np.array(result_157[i]).reshape(10,10) for i in range(10)]

plot_v0(res=res_157)
plot_T(res=res_157)
plot_s0(res=res_157)
plot_a(res=res_157)

"""To check if IDM acceleration gives same output as given in .out file"""

print(f'idm int acceleration{IDM.calcAccInt(IDM(v0=6.882, T=1.404, s0=0.421, a=0.969, b=4.701),0.4649,0.0357,0.0)}')
print(f'idm free acceleration{IDM.calcAccFree(IDM(v0=6.882, T=1.404, s0=0.421, a=0.969, b=4.701),0.0357)}')
print(f'idm long acceleration{IDM.calcAccLong(IDM(v0=6.882, T=1.404, s0=0.421, a=0.969, b=4.701),0.4649,0.0357,0.0)}')

"""IDM acceleration output is same for given hats, hatv, vlead

### Subject Vehicle 1085
"""

print('FOLLOWING RESULTS ARE FOR SUBJECT 1085')
FCdata1085=singleleader(4,1085)

"""Calibrated parameters and result as per file "d8_0900_0930_road4_veh085_IDM_s.out"

v0=21.397, T=0.862, s0=1.388, a=1.445, b=3.608

resuting_SSE for above parameters: 504.07
average error=0.83m
"""

sim1085=sim(v0=21.397, T=0.862, s0=1.388, a=1.445, b=3.608,FCdata=FCdata1085)

sse=sim1085[0]
avg_error=sim1085[1]

print(f'Subject 1085: For simulation by Ankit: sse is {sse} and average error is {avg_error}m')
print(f'Subject 1085: For simulation by Martin: sse is 504.07 and average error is 0.83 m')


speed_gap_plt(sim1085[2])

"""Comparison between b1 and b2

From given results

for base values: sse= 504.069

case 1: beta1 = 0.565287; beta2=0.878892; sse=1890.632511

case 2: beta1 = 0.644422; beta2=1.252157; sse=931.141595

case 3: beta1 = 0.743341; beta2=1.591490; sse=561.596315

"""

sim_b1_b2_1=sim(v0=21.397, T=0.565287, s0=0.878892, a=1.445, b=3.608,FCdata=FCdata1085)

print(f'1. sse is {sim_b1_b2_1[0]}')

sim_b1_b2_2=sim(v0=21.397, T=0.644422, s0=1.252157, a=1.445, b=3.608,FCdata=FCdata1085)

print(f'2. sse is {sim_b1_b2_2[0]}')

sim_b1_b2_3=sim(v0=21.397, T=0.743341, s0=1.591490, a=1.445, b=3.608,FCdata=FCdata1085)

print(f'3. sse is {sim_b1_b2_3[0]}')

"""Comparison between b3 and b4

From given results

for base values: sse= 504.069

case 1: beta3 = 1.043084; beta4= 0.05; sse=5040.694900

case 2: beta3 = 1.230431; beta4=4.361667; sse=992.785432

case 3: beta3 = 1.498071; beta4=4.693333; sse=519.680385

"""

sim_b3_b4_1=sim(v0=21.397, T=0.862, s0=1.388, a=1.043084, b=0.05,FCdata=FCdata1085)

print(f'1. sse is {sim_b3_b4_1[0]}')

sim_b3_b4_2=sim(v0=21.397, T=0.862, s0=1.388, a=1.230431, b=4.361667,FCdata=FCdata1085)

print(f'2. sse is {sim_b3_b4_2[0]}')

sim_b3_b4_3=sim(v0=21.397, T=0.862, s0=1.388, a=1.498071, b=4.693333,FCdata=FCdata1085)

print(f'3. sse is {sim_b3_b4_3[0]}')

# For subject vehicle 1085

b0=np.linspace(6.395586,50,31)
b1=np.linspace(0.565287,1.158800,31)
b2=np.linspace(0.878892,1.896889,31)
b3=np.linspace(1.043084,1.846003,31)
b4=np.linspace(0.05,10,31)

b0b1=(np.array(np.meshgrid(b0,b1)).T.reshape(-1,2))
b0b2=(np.array(np.meshgrid(b0,b2)).T.reshape(-1,2))
b0b3=(np.array(np.meshgrid(b0,b3)).T.reshape(-1,2))
b0b4=(np.array(np.meshgrid(b0,b4)).T.reshape(-1,2))
b1b2=(np.array(np.meshgrid(b1,b2)).T.reshape(-1,2))
b1b3=(np.array(np.meshgrid(b1,b3)).T.reshape(-1,2))
b1b4=(np.array(np.meshgrid(b1,b4)).T.reshape(-1,2))
b2b3=(np.array(np.meshgrid(b2,b3)).T.reshape(-1,2))
b2b4=(np.array(np.meshgrid(b2,b4)).T.reshape(-1,2))
b3b4=(np.array(np.meshgrid(b3,b4)).T.reshape(-1,2))

def sim_sse_1085(v0=21.397, T=0.862, s0=1.388, a=1.445, b=3.608,FCdata=FCdata1085):
    
    data=FCdata
    dt=0.2
   # print(f'v0:{v0},T:{T},s0:{s0},a:{a},b:{b}')
    CF=IDM(v0,T,s0,a,b)    # IDM model as defined above
    
    #First step as per oberved data
    data.loc[0,'v1']=data.loc[0,'vx[m/s]'] 
    data.loc[0,'x1']=data.loc[0,'x[m]']
    data.loc[0,'gap1']=data.loc[0,'gap[m]']
    #data.loc['accln']=data.apply(lambda x: CF.calcAccLong(x['gap1'],x['v1'],x['lead_vx']),axis=1) 
    data.loc[0,'accln']=CF.calcAccLong(data.loc[0,'gap1'],data.loc[0,'v1'],data.loc[0,'lead_vx']) 
    for i in range(1,len(data)):

        if data.loc[i,'leadID']!=data.loc[i-1,'leadID']:  # to check if leader is same or not
            
            #if leader is not same then update speed and position to observed 
            data.loc[i,'v1']=data.loc[i,'vx[m/s]']
            data.loc[i,'x1']=data.loc[i,'x[m]']
   
        else:
            data.loc[i,'v1']=data.loc[i-1,'v1']+data.loc[i-1,'accln']*dt  #calculation of simulated speed "hatv" using previous step v and acc
            data.loc[i,'x1']=data.loc[i-1,'x1']+ data.loc[i-1,'v1']*dt+0.5*data.loc[i-1,'accln']*dt*dt #calculation of simulated position "hatx" using previous step x, v and acc
            if data.loc[i,'v1']<-1e-6:
                data.loc[i,'v1']=0
                data.loc[i,'x1']=data.loc[i-1,'x1']-0.5*data.loc[i-1,'v1']**2/data.loc[i-1,'accln']
        data.loc[i,'gap1']=data.loc[i,'gap[m]']+data.loc[i,'x[m]']-data.loc[i,'x1'] #calculation of simulated gap hats using current step simulated x and leader position
        data.loc[i,'accln']=CF.calcAccLong(data.loc[i,'gap1'],data.loc[i,'v1'],data.loc[i,'lead_vx']) #calcualation of acceleration hata using current step "hatv","hats", leadv
    
    sse= sum((data['gap1']-data['gap[m]'])**2)
    avg_error=sum(abs(data['gap1']-data['gap[m]']))/len(data)
    return  sse


resultsb01= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(v0=i[0],T=i[1]) for i in b0b1)
resultsb02= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(v0=i[0],s0=i[1]) for i in b0b2)
resultsb03= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(v0=i[0],a=i[1]) for i in b0b3)
resultsb04= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(v0=i[0],b=i[1]) for i in b0b4)
resultsb12= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(T=i[0],s0=i[1]) for i in b1b2)
resultsb13= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(T=i[0],a=i[1]) for i in b1b3)
resultsb14= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(T=i[0],b=i[1]) for i in b1b4)
resultsb23= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(s0=i[0],a=i[1]) for i in b2b3)
resultsb24= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(s0=i[0],b=i[1]) for i in b2b4)
resultsb34= Parallel(n_jobs=num_cores)(delayed(sim_sse_1085)(a=i[0],b=i[1]) for i in b3b4)

result_1085=[resultsb01,resultsb02,resultsb03,resultsb04,resultsb12,resultsb13,resultsb14,resultsb23,resultsb24,resultsb34]

res_1085=[np.array(result_1085[i]).reshape(10,10) for i in range(10)]

plot_v0(res=res_1085)
plot_T(res=res_1085)
plot_s0(res=res_1085)
plot_a(res=res_1085)








#sim_sse(a=1.043084, b=0.713333)

#num_cores = multiprocessing.cpu_count()
#resultsb34 = Parallel(n_jobs=num_cores)(delayed(sim_sse)(a=i[0],b=i[1]) for i in b3b4)

#resultsb02 = Parallel(n_jobs=num_cores)(delayed(sim_sse)(v0=i[0],s0=i[1]) for i in b0b2)

#resultsb12 = Parallel(n_jobs=num_cores)(delayed(sim_sse)(T=i[0],s0=i[1]) for i in b1b2)

#res=np.array(resultsb34).reshape(31,31)
#plt.contourf(b3, b4, np.transpose(res), cmap='Dark2')

#plt.colorbar()
#plt.show()

#res=np.array(resultsb02).reshape(31,31)
#plt.contourf(b0, b2, np.transpose(res), cmap='Dark2')

#plt.colorbar()
#plt.show()

"""### Loopy loop"""

#x=np.linspace(0.565287,1.158800,31)

#y=np.linspace(0.878892,1.896889,31)
#X,Y=np.meshgrid(x,y)
#Z=[]
#for j in tqdm(range(len(X))):
#    for i in range(len(X[0])):
#
#        Z.append(sim1085((X[j][i],Y[j][i])))

"""### Compare"""

#Z=np.array(Z).reshape(X.shape)
#plt.contourf(X, Y, Z, cmap='Dark2')
#plt.colorbar()

plt.contourf(X,Y,np.transpose(res),cmap='Dark2')
plt.colorbar()


